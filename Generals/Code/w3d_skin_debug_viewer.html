<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>W3D Skin Debug Viewer</title>
  <style>
    html, body { margin: 0; height: 100%; background: #111; color: #ddd; font: 13px/1.35 Arial, sans-serif; }
    #root { display: grid; grid-template-columns: 360px 1fr; height: 100%; }
    #ui { overflow: auto; padding: 10px; border-right: 1px solid #333; background: #181818; }
    #view { position: relative; }
    .row { margin: 7px 0; display: grid; grid-template-columns: 120px 1fr; gap: 8px; align-items: center; }
    .row.full { grid-template-columns: 1fr; }
    label { color: #aaa; }
    select, input[type="file"], input[type="number"], button {
      width: 100%; box-sizing: border-box; background: #232323; color: #ddd; border: 1px solid #444; border-radius: 4px; padding: 6px;
    }
    input[type="range"] { width: 100%; }
    button { cursor: pointer; }
    button:hover { background: #2b2b2b; }
    .sep { border-top: 1px solid #2f2f2f; margin: 10px 0; }
    .chk { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .chk label { display: inline-flex; gap: 6px; align-items: center; }
    #status { white-space: pre-wrap; font-family: Consolas, monospace; background: #101010; border: 1px solid #333; border-radius: 4px; padding: 8px; max-height: 180px; overflow: auto; }
    #help { color: #8f8f8f; font-size: 12px; }
    #canvasHost { position: absolute; inset: 0; }
    #boneLabels { position: absolute; inset: 0; pointer-events: none; overflow: hidden; }
    .bone-label {
      position: absolute; transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.65); border: 1px solid #555; border-radius: 3px;
      padding: 1px 5px; font: 11px/1.4 Consolas, monospace; color: #ffe87c;
      white-space: nowrap; pointer-events: none;
    }
    .bone-label.highlight { color: #ff6060; border-color: #ff6060; background: rgba(80,0,0,0.75); }
  </style>
</head>
<body>
  <div id="root">
    <div id="ui">
      <div class="row full">
        <label><b>Load W3D files</b> (SKN, SKL, optional anim clips)</label>
        <input id="fileInput" type="file" accept=".w3d" multiple />
      </div>

      <div class="row"><label>Mesh file (SKN)</label><select id="meshSelect"></select></div>
      <div class="row"><label>Skeleton file (SKL)</label><select id="sklSelect"></select></div>
      <div class="row full"><button id="loadModelBtn">Load Model + Skeleton</button></div>

      <div class="sep"></div>
      <div class="row"><label>Animation file</label><select id="animFileSelect"></select></div>
      <div class="row"><label>Animation clip</label><select id="clipSelect"></select></div>
      <div class="row full"><button id="refreshClipsBtn">Refresh Clips From Anim File</button></div>

      <div class="sep"></div>
      <div class="row full chk">
        <label><input id="showMeshChk" type="checkbox" checked />Show mesh</label>
        <label><input id="showBonesChk" type="checkbox" checked />Show bones</label>
        <label><input id="applySkinChk" type="checkbox" checked />Apply skinning</label>
        <label><input id="playAnimChk" type="checkbox" />Play clip</label>
        <label><input id="wireChk" type="checkbox" />Wireframe</label>
        <label><input id="showLabelsChk" type="checkbox" checked />Bone labels</label>
        <label><input id="showAxesChk" type="checkbox" />Bone axes</label>
      </div>
      <div class="row">
        <label>Skin mode</label>
        <select id="skinModeSelect">
          <option value="delta">Delta (current * inverseBind)</option>
          <option value="boneSpace">Bone-space (current only)</option>
        </select>
      </div>
      <div class="row">
        <label>Rot formula</label>
        <select id="rotFormulaSelect">
          <option value="A">A: bind * anim (default)</option>
          <option value="B">B: anim only (absolute)</option>
          <option value="C">C: anim * bind (reversed)</option>
        </select>
      </div>

      <div class="sep"></div>
      <div class="row"><label>Manual bone</label><select id="boneSelect"></select></div>
      <div class="row"><label>Rot X (deg)</label><input id="rx" type="range" min="-180" max="180" step="1" value="0"></div>
      <div class="row"><label>Rot Y (deg)</label><input id="ry" type="range" min="-180" max="180" step="1" value="0"></div>
      <div class="row"><label>Rot Z (deg)</label><input id="rz" type="range" min="-180" max="180" step="1" value="0"></div>
      <div class="row"><label>Pos X</label><input id="tx" type="range" min="-5" max="5" step="0.01" value="0"></div>
      <div class="row"><label>Pos Y</label><input id="ty" type="range" min="-5" max="5" step="0.01" value="0"></div>
      <div class="row"><label>Pos Z</label><input id="tz" type="range" min="-5" max="5" step="0.01" value="0"></div>
      <div class="row full"><button id="resetPoseBtn">Reset Manual Bone Offset</button></div>

      <div class="sep"></div>
      <div class="row"><label>Highlight keyword</label><input id="highlightInput" type="text" placeholder="e.g. gun, hand" style="padding:5px;" /></div>
      <div class="row full"><button id="dumpPivotsBtn">Dump Pivots to Console</button></div>
      <div class="row full"><button id="logBarrelBtn">Log gun barrel direction</button></div>

      <div class="sep"></div>
      <div class="row"><label>Compare bone A</label><input id="cmpBoneA" type="text" placeholder="e.g. BONE-GUN" style="padding:4px;" /></div>
      <div class="row"><label>Compare bone B</label><input id="cmpBoneB" type="text" placeholder="e.g. R HAND" style="padding:4px;" /></div>
      <div id="cmpResult" style="font-size:11px;color:#9f9;padding:4px 0;white-space:pre-wrap;word-break:break-all;"></div>

      <div class="sep"></div>
      <div class="row"><label style="font-weight:bold">Axis correction</label></div>
      <div class="row"><label>Bone name</label><input id="axisCorrBone" type="text" value="BONE-GUN" style="padding:4px;" /></div>
      <div class="row"><label>Apply as</label>
        <select id="axisCorrMode">
          <option value="post">Post: (bind*anim) * corr</option>
          <option value="pre">Pre: corr * (bind*anim)</option>
        </select>
      </div>
      <div class="row"><label>Corr X (deg)</label><input id="axisCorrX" type="range" min="-180" max="180" step="1" value="0"><span id="axisCorrXVal">0°</span></div>
      <div class="row"><label>Corr Y (deg)</label><input id="axisCorrY" type="range" min="-180" max="180" step="1" value="0"><span id="axisCorrYVal">0°</span></div>
      <div class="row"><label>Corr Z (deg)</label><input id="axisCorrZ" type="range" min="-180" max="180" step="1" value="0"><span id="axisCorrZVal">0°</span></div>
      <div class="row full"><button id="axisCorrResetBtn">Reset correction</button></div>
      <div class="row full"><button id="axisCorrLogBtn">Log corrective quaternion</button></div>
      <div id="axisCorrResult" style="font-size:11px;color:#ff9;padding:4px 0;white-space:pre-wrap;word-break:break-all;"></div>

      <div class="sep"></div>
      <div id="help">
        Tip: set <b>Play clip</b> OFF and move one bone manually to inspect weight/influence behavior.<br/>
        With <b>Apply skinning</b> OFF, you can compare base (bind) mesh vs deformed mesh.
      </div>
      <div class="row full"><div id="status"></div></div>
    </div>
    <div id="view"><div id="canvasHost"></div><div id="boneLabels"></div></div>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "./map-viewer/node_modules/three/build/three.module.js"
      }
    }
  </script>
  <script type="module">
    import * as THREE from "./map-viewer/node_modules/three/build/three.module.js";
    import { OrbitControls } from "./map-viewer/node_modules/three/examples/jsm/controls/OrbitControls.js";
    // ---------- W3D constants ----------
    const CH_MESH = 0x00000000;
    const CH_MESH_HEADER3 = 0x0000001F;
    const CH_VERTICES = 0x00000002;
    const CH_NORMALS = 0x00000003;
    const CH_TRIANGLES = 0x00000020;
    const CH_VERTEX_INFLUENCES = 0x0000000E;
    const CH_TEXTURES = 0x00000030;
    const CH_TEXTURE = 0x00000031;
    const CH_TEXTURE_NAME = 0x00000032;
    const CH_MATERIAL_PASS = 0x00000038;
    const CH_STAGE_TEXCOORDS = 0x0000004A;

    const CH_HIERARCHY = 0x00000100;
    const CH_HIERARCHY_HEADER = 0x00000101;
    const CH_PIVOTS = 0x00000102;

    const CH_HLOD = 0x00000700;
    const CH_HLOD_HEADER = 0x00000701;
    const CH_HLOD_LOD_ARRAY = 0x00000702;
    const CH_HLOD_SUB_OBJECT = 0x00000704;

    const CH_ANIM = 0x00000200;
    const CH_ANIM_HEADER = 0x00000201;
    const CH_ANIM_CHANNEL = 0x00000202;

    const W3D_MESH_FLAG_COLLISION_BOX = 0x00000001;
    const W3D_MESH_FLAG_COLLISION_TYPE_MASK = 0x00000FF0;
    const W3D_MESH_FLAG_HIDDEN = 0x00001000;
    const W3D_MESH_FLAG_GEOMETRY_TYPE_MASK = 0x00FF0000;
    const W3D_MESH_FLAG_GEOMETRY_TYPE_SKIN = 0x00020000;
    const W3D_MESH_FLAG_SKIN_LEGACY = 0x00000002;

    // ---------- App state ----------
    const filesByName = new Map();      // lower filename -> File
    const parsedByName = new Map();     // lower filename -> parsed w3d

    let scene, camera, renderer, controls;
    let worldRoot = null;
    let skeletonRoot = null;
    let skeletonHelper = null;
    let modelGroup = null;
    let bonesByPivot = new Map();
    let skinnedMeshes = [];
    let allMeshes = [];
    let boneAxisHelpers = [];  // THREE.AxesHelper per bone
    let lastTime = performance.now();
    let activeClip = null;
    let clipTimeFrames = 0;
    const boneLabelsEl = document.getElementById('boneLabels');
    const _screenPos = new THREE.Vector3();

    const _tmpQ1 = new THREE.Quaternion();
    const _tmpQ2 = new THREE.Quaternion();
    const _tmpM1 = new THREE.Matrix4();
    const _tmpM2 = new THREE.Matrix4();
    const _tmpM3 = new THREE.Matrix4();
    const _tmpM3n = new THREE.Matrix3();
    const _tmpV = new THREE.Vector3();
    const _tmpN = new THREE.Vector3();

    // ---------- UI ----------
    const ui = {
      fileInput: document.getElementById('fileInput'),
      meshSelect: document.getElementById('meshSelect'),
      sklSelect: document.getElementById('sklSelect'),
      animFileSelect: document.getElementById('animFileSelect'),
      clipSelect: document.getElementById('clipSelect'),
      loadModelBtn: document.getElementById('loadModelBtn'),
      refreshClipsBtn: document.getElementById('refreshClipsBtn'),
      showMeshChk: document.getElementById('showMeshChk'),
      showBonesChk: document.getElementById('showBonesChk'),
      applySkinChk: document.getElementById('applySkinChk'),
      playAnimChk: document.getElementById('playAnimChk'),
      wireChk: document.getElementById('wireChk'),
      showLabelsChk: document.getElementById('showLabelsChk'),
      showAxesChk: document.getElementById('showAxesChk'),
      skinModeSelect: document.getElementById('skinModeSelect'),
      rotFormulaSelect: document.getElementById('rotFormulaSelect'),
      boneSelect: document.getElementById('boneSelect'),
      rx: document.getElementById('rx'),
      ry: document.getElementById('ry'),
      rz: document.getElementById('rz'),
      tx: document.getElementById('tx'),
      ty: document.getElementById('ty'),
      tz: document.getElementById('tz'),
      resetPoseBtn: document.getElementById('resetPoseBtn'),
      dumpPivotsBtn: document.getElementById('dumpPivotsBtn'),
      logBarrelBtn: document.getElementById('logBarrelBtn'),
      cmpBoneA: document.getElementById('cmpBoneA'),
      cmpBoneB: document.getElementById('cmpBoneB'),
      cmpResult: document.getElementById('cmpResult'),
      axisCorrBone: document.getElementById('axisCorrBone'),
      axisCorrMode: document.getElementById('axisCorrMode'),
      axisCorrX: document.getElementById('axisCorrX'),
      axisCorrY: document.getElementById('axisCorrY'),
      axisCorrZ: document.getElementById('axisCorrZ'),
      axisCorrXVal: document.getElementById('axisCorrXVal'),
      axisCorrYVal: document.getElementById('axisCorrYVal'),
      axisCorrZVal: document.getElementById('axisCorrZVal'),
      axisCorrResetBtn: document.getElementById('axisCorrResetBtn'),
      axisCorrLogBtn: document.getElementById('axisCorrLogBtn'),
      axisCorrResult: document.getElementById('axisCorrResult'),
      highlightInput: document.getElementById('highlightInput'),
      status: document.getElementById('status'),
    };

    function log(msg) {
      ui.status.textContent = (msg + "\n" + ui.status.textContent).slice(0, 5000);
    }

    function iterChunks(view, start, end, fn) {
      let pos = start;
      while (pos + 8 <= end) {
        const id = view.getUint32(pos, true);
        const sizeRaw = view.getUint32(pos + 4, true);
        const size = sizeRaw & 0x7fffffff;
        const dStart = pos + 8;
        const dEnd = Math.min(dStart + size, end);
        fn(id, dStart, dEnd, size);
        pos = dEnd;
      }
    }

    function readFixedString(view, off, len) {
      let s = "";
      for (let i = 0; i < len; i++) {
        const c = view.getUint8(off + i);
        if (!c) break;
        s += String.fromCharCode(c);
      }
      return s;
    }

    function parseW3D(arrayBuffer) {
      const view = new DataView(arrayBuffer);
      const meshes = [];
      let hierarchy = null;
      let hlod = null;
      const animations = [];

      function parseMesh(start, end) {
        const mesh = {
          name: "",
          attrs: 0,
          vertices: null,
          normals: null,
          triangles: null,
          uvs: null,
          textureNames: [],
          numVerts: 0,
          boneLinks: null,
        };
        iterChunks(view, start, end, (id, ds, de, size) => {
          if (id === CH_MESH_HEADER3 && size >= 48) {
            mesh.attrs = view.getUint32(ds + 4, true);
            mesh.name = readFixedString(view, ds + 8, 16);
            mesh.numVerts = view.getUint32(ds + 44, true);
          } else if (id === CH_VERTICES) {
            const c = Math.floor(size / 12);
            mesh.vertices = new Float32Array(c * 3);
            for (let i = 0; i < c; i++) {
              mesh.vertices[i*3] = view.getFloat32(ds + i*12, true);
              mesh.vertices[i*3+1] = view.getFloat32(ds + i*12 + 4, true);
              mesh.vertices[i*3+2] = view.getFloat32(ds + i*12 + 8, true);
            }
          } else if (id === CH_NORMALS) {
            const c = Math.floor(size / 12);
            mesh.normals = new Float32Array(c * 3);
            for (let i = 0; i < c; i++) {
              mesh.normals[i*3] = view.getFloat32(ds + i*12, true);
              mesh.normals[i*3+1] = view.getFloat32(ds + i*12 + 4, true);
              mesh.normals[i*3+2] = view.getFloat32(ds + i*12 + 8, true);
            }
          } else if (id === CH_TRIANGLES) {
            const c = Math.floor(size / 32);
            mesh.triangles = new Uint32Array(c * 3);
            for (let i = 0; i < c; i++) {
              mesh.triangles[i*3] = view.getUint32(ds + i*32, true);
              mesh.triangles[i*3+1] = view.getUint32(ds + i*32 + 4, true);
              mesh.triangles[i*3+2] = view.getUint32(ds + i*32 + 8, true);
            }
          } else if (id === CH_VERTEX_INFLUENCES) {
            const c = Math.floor(size / 8);
            mesh.boneLinks = new Uint16Array(c);
            for (let i = 0; i < c; i++) {
              // For C&C Generals infantry assets this is the working pivot index field.
              mesh.boneLinks[i] = view.getUint16(ds + i*8, true);
            }
          } else if (id === CH_TEXTURES) {
            iterChunks(view, ds, de, (tid, ts, te, tsize) => {
              if (tid === CH_TEXTURE) {
                iterChunks(view, ts, te, (nid, ns, ne, nsize) => {
                  if (nid === CH_TEXTURE_NAME) mesh.textureNames.push(readFixedString(view, ns, nsize));
                });
              }
            });
          } else if (id === CH_MATERIAL_PASS) {
            iterChunks(view, ds, de, (sid, ss, se, ssize) => {
              if (sid === CH_STAGE_TEXCOORDS && !mesh.uvs) {
                const c = Math.floor(ssize / 8);
                mesh.uvs = new Float32Array(c * 2);
                for (let i = 0; i < c; i++) {
                  mesh.uvs[i*2] = view.getFloat32(ss + i*8, true);
                  mesh.uvs[i*2+1] = view.getFloat32(ss + i*8 + 4, true);
                }
              }
            });
          }
        });
        return mesh;
      }

      function parseHierarchy(start, end) {
        const out = { name: "", pivots: [] };
        iterChunks(view, start, end, (id, ds, de, size) => {
          if (id === CH_HIERARCHY_HEADER) {
            out.name = readFixedString(view, ds + 4, 16);
          } else if (id === CH_PIVOTS) {
            const c = Math.floor(size / 60);
            for (let i = 0; i < c; i++) {
              const o = ds + i*60;
              out.pivots.push({
                name: readFixedString(view, o + 0, 16),
                parentIdx: view.getUint32(o + 16, true),
                t: [view.getFloat32(o + 20, true), view.getFloat32(o + 24, true), view.getFloat32(o + 28, true)],
                q: [view.getFloat32(o + 44, true), view.getFloat32(o + 48, true), view.getFloat32(o + 52, true), view.getFloat32(o + 56, true)],
              });
            }
          }
        });
        return out;
      }

      function parseHLOD(start, end) {
        const out = { name: "", hierarchy: "", lods: [] };
        iterChunks(view, start, end, (id, ds, de) => {
          if (id === CH_HLOD_HEADER) {
            out.name = readFixedString(view, ds + 8, 16);
            out.hierarchy = readFixedString(view, ds + 24, 16);
          } else if (id === CH_HLOD_LOD_ARRAY) {
            const sub = [];
            iterChunks(view, ds, de, (sid, ss, se, ssize) => {
              if (sid === CH_HLOD_SUB_OBJECT) {
                sub.push({
                  boneIdx: view.getUint32(ss, true),
                  name: readFixedString(view, ss + 4, ssize - 4),
                });
              }
            });
            out.lods.push(sub);
          }
        });
        return out;
      }

      function parseAnimation(start, end) {
        const clip = { name: "", hierarchyName: "", numFrames: 0, frameRate: 30, channels: [] };
        iterChunks(view, start, end, (id, ds, de, size) => {
          if (id === CH_ANIM_HEADER && size >= 44) {
            clip.name = readFixedString(view, ds + 4, 16).toLowerCase();
            clip.hierarchyName = readFixedString(view, ds + 20, 16).toLowerCase();
            clip.numFrames = view.getUint32(ds + 36, true);
            clip.frameRate = view.getUint32(ds + 40, true);
          } else if (id === CH_ANIM_CHANNEL && size >= 12) {
            const first = view.getUint16(ds + 0, true);
            const last = view.getUint16(ds + 2, true);
            const vlen = view.getUint16(ds + 4, true);
            const type = view.getUint16(ds + 6, true);
            const pivot = view.getUint16(ds + 8, true);
            const sampleCount = Math.max(0, last - first + 1);
            const valCount = Math.min(sampleCount * vlen, Math.floor((size - 12) / 4));
            const data = new Float32Array(valCount);
            for (let i = 0; i < valCount; i++) data[i] = view.getFloat32(ds + 12 + i*4, true);
            let kind = null;
            if (vlen === 4) kind = "q";
            else if (vlen === 1 && type === 0) kind = "x";
            else if (vlen === 1 && type === 1) kind = "y";
            else if (vlen === 1 && type === 2) kind = "z";
            if (kind) clip.channels.push({ kind, first, last, vlen, pivot, data });
          }
        });
        if (clip.name) animations.push(clip);
      }

      iterChunks(view, 0, arrayBuffer.byteLength, (id, ds, de) => {
        if (id === CH_MESH) meshes.push(parseMesh(ds, de));
        else if (id === CH_HIERARCHY) hierarchy = parseHierarchy(ds, de);
        else if (id === CH_HLOD) hlod = parseHLOD(ds, de);
        else if (id === CH_ANIM) parseAnimation(ds, de);
      });

      return { meshes, hierarchy, hlod, animations };
    }

    function resetSceneModel() {
      if (worldRoot) {
        scene.remove(worldRoot);
      }
      worldRoot = new THREE.Group();
      scene.add(worldRoot);
      skeletonRoot = null;
      skeletonHelper = null;
      modelGroup = null;
      bonesByPivot = new Map();
      skinnedMeshes = [];
      allMeshes = [];
      boneAxisHelpers = [];
      activeClip = null;
      clipTimeFrames = 0;
      boneLabelsEl.innerHTML = "";
      ui.boneSelect.innerHTML = "";
    }

    function addSelectOption(sel, value, label) {
      const o = document.createElement("option");
      o.value = value;
      o.textContent = label;
      sel.appendChild(o);
    }

    function refreshFileSelects() {
      for (const sel of [ui.meshSelect, ui.sklSelect, ui.animFileSelect]) sel.innerHTML = "";
      addSelectOption(ui.meshSelect, "", "(choose)");
      addSelectOption(ui.sklSelect, "", "(auto or choose)");
      addSelectOption(ui.animFileSelect, "", "(none)");

      const names = [...filesByName.keys()].sort();
      for (const n of names) {
        addSelectOption(ui.meshSelect, n, n);
        addSelectOption(ui.sklSelect, n, n);
        addSelectOption(ui.animFileSelect, n, n);
      }
    }

    async function parseAndCache(nameLower) {
      if (parsedByName.has(nameLower)) return parsedByName.get(nameLower);
      const f = filesByName.get(nameLower);
      if (!f) return null;
      const buf = await f.arrayBuffer();
      const parsed = parseW3D(buf);
      parsedByName.set(nameLower, parsed);
      return parsed;
    }

    async function buildModel() {
      const meshName = ui.meshSelect.value;
      if (!meshName) {
        log("Pick a mesh .w3d first.");
        return;
      }
      resetSceneModel();

      const meshData = await parseAndCache(meshName);
      if (!meshData || !meshData.meshes.length) {
        log("Selected file has no mesh chunks.");
        return;
      }

      let hierarchy = meshData.hierarchy;
      let sklName = ui.sklSelect.value;
      if (!hierarchy && meshData.hlod && meshData.hlod.hierarchy) {
        const auto = (meshData.hlod.hierarchy + ".w3d").toLowerCase();
        if (!sklName && filesByName.has(auto)) sklName = auto;
      }
      if (!hierarchy && sklName) {
        const sklData = await parseAndCache(sklName);
        if (sklData && sklData.hierarchy) hierarchy = sklData.hierarchy;
      }

      modelGroup = new THREE.Group();
      modelGroup.name = "ModelRoot";
      modelGroup.rotation.x = -Math.PI / 2; // keep parity with map-viewer orientation
      worldRoot.add(modelGroup);

      const meshPivotIdx = new Map();
      if (meshData.hlod && meshData.hlod.lods.length) {
        const lod0 = meshData.hlod.lods[meshData.hlod.lods.length - 1];
        for (const sub of lod0) {
          const parts = sub.name.toLowerCase().split(".");
          const mname = parts.length > 1 ? parts[1] : parts[0];
          meshPivotIdx.set(mname, sub.boneIdx);
        }
      }

      if (hierarchy && hierarchy.pivots.length) {
        skeletonRoot = new THREE.Group();
        skeletonRoot.name = "SkeletonRoot";
        modelGroup.add(skeletonRoot);

        const bones = [];
        for (let i = 0; i < hierarchy.pivots.length; i++) {
          const p = hierarchy.pivots[i];
          const b = new THREE.Bone();
          b.name = p.name || ("pivot_" + i);
          if (i > 0) {
            b.position.set(p.t[0], p.t[1], p.t[2]);
            b.quaternion.set(p.q[0], p.q[1], p.q[2], p.q[3]);
          }
          b.userData.pivotIndex = i;
          b.userData.bindPosition = b.position.clone();
          b.userData.bindQuaternion = b.quaternion.clone();
          bones.push(b);
          bonesByPivot.set(i, b);
        }
        for (let i = 0; i < bones.length; i++) {
          const parent = hierarchy.pivots[i].parentIdx;
          if (parent === 0xffffffff || parent >= bones.length) skeletonRoot.add(bones[i]);
          else bones[parent].add(bones[i]);
        }

        // Add per-bone axis helpers (size 1 unit) — toggled by "Bone axes" checkbox.
        boneAxisHelpers = [];
        for (const [i, bone] of bonesByPivot) {
          const ax = new THREE.AxesHelper(1.5);
          ax.material.depthTest = false;
          ax.userData.boneIdx = i;
          bone.add(ax);
          boneAxisHelpers.push(ax);
        }

        skeletonHelper = new THREE.SkeletonHelper(skeletonRoot);
        skeletonHelper.material.depthTest = false;
        skeletonHelper.material.transparent = true;
        skeletonHelper.material.opacity = 0.85;
        worldRoot.add(skeletonHelper);

        ui.boneSelect.innerHTML = "";
        addSelectOption(ui.boneSelect, "", "(none)");
        for (let i = 0; i < hierarchy.pivots.length; i++) {
          const p = hierarchy.pivots[i];
          addSelectOption(ui.boneSelect, String(i), `${i}: ${p.name}`);
        }
      }

      for (const m of meshData.meshes) {
        if (!m.vertices || !m.triangles) continue;
        if (m.attrs & W3D_MESH_FLAG_HIDDEN) continue;
        if (m.attrs & (W3D_MESH_FLAG_COLLISION_BOX | W3D_MESH_FLAG_COLLISION_TYPE_MASK)) continue;
        const lname = m.name.toLowerCase();
        if (lname.includes("shadow") || lname.includes("collision")) continue;

        const g = new THREE.BufferGeometry();
        g.setAttribute("position", new THREE.Float32BufferAttribute(m.vertices, 3));
        if (m.normals) g.setAttribute("normal", new THREE.Float32BufferAttribute(m.normals, 3));
        if (m.uvs) g.setAttribute("uv", new THREE.Float32BufferAttribute(m.uvs, 2));
        g.setIndex(new THREE.BufferAttribute(m.triangles, 1));
        if (!m.normals) g.computeVertexNormals();

        const mat = new THREE.MeshStandardMaterial({ color: 0xbdbdbd, metalness: 0.0, roughness: 0.95 });
        const mesh = new THREE.Mesh(g, mat);
        mesh.name = m.name;
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        allMeshes.push(mesh);

        const isSkin = !!(m.boneLinks && m.boneLinks.length) &&
          (((m.attrs & W3D_MESH_FLAG_GEOMETRY_TYPE_MASK) === W3D_MESH_FLAG_GEOMETRY_TYPE_SKIN) || (m.attrs & W3D_MESH_FLAG_SKIN_LEGACY));

        if (isSkin && bonesByPivot.size) {
          const posAttr = g.getAttribute("position");
          const normAttr = g.getAttribute("normal");
          const usedPivots = [...new Set(m.boneLinks)];
          mesh.userData.cpuSkin = {
            links: m.boneLinks,
            usedPivots,
            posAttr,
            normAttr,
            bindPositions: Float32Array.from(posAttr.array),
            bindNormals: normAttr ? Float32Array.from(normAttr.array) : null,
            bindBoneToMeshInv: [],
          };
          skinnedMeshes.push(mesh);
          modelGroup.add(mesh);
        } else {
          const mapped = meshPivotIdx.get(lname);
          if (Number.isInteger(mapped) && bonesByPivot.has(mapped)) bonesByPivot.get(mapped).add(mesh);
          else modelGroup.add(mesh);
        }
      }

      modelGroup.updateMatrixWorld(true);

      // Capture inverse bind matrices per pivot in mesh-local space.
      for (const mesh of skinnedMeshes) {
        const skin = mesh.userData.cpuSkin;
        const meshWorldInv = _tmpM1.copy(mesh.matrixWorld).invert();
        for (const p of skin.usedPivots) {
          const bone = bonesByPivot.get(p);
          if (!bone) continue;
          _tmpM2.multiplyMatrices(meshWorldInv, bone.matrixWorld);
          _tmpM2.invert();
          skin.bindBoneToMeshInv[p] = Float32Array.from(_tmpM2.elements);
        }
      }

      const bCount = bonesByPivot.size;
      log(`Loaded model: ${meshName}`);
      log(`Meshes: ${allMeshes.length}, skinned meshes: ${skinnedMeshes.length}, bones: ${bCount}`);
      if (meshData.hlod && meshData.hlod.hierarchy) log(`HLOD hierarchy ref: ${meshData.hlod.hierarchy}`);
      if (!bCount) log("No hierarchy loaded: bone debug + skinning won't run.");

      updateVisualToggles();
      refreshClipSelectFromAnimFile();
      frameToFit();
    }

    function updateVisualToggles() {
      const showMesh = ui.showMeshChk.checked;
      for (const m of allMeshes) m.visible = showMesh;
      if (skeletonHelper) skeletonHelper.visible = ui.showBonesChk.checked;
      const showAxes = ui.showAxesChk.checked;
      for (const ax of boneAxisHelpers) ax.visible = showAxes;
      for (const m of allMeshes) {
        if (m.material) m.material.wireframe = ui.wireChk.checked;
      }
    }

    function applyBindPose() {
      for (const [i, b] of bonesByPivot) {
        if (i === 0) continue;
        if (b.userData.bindPosition) b.position.copy(b.userData.bindPosition);
        if (b.userData.bindQuaternion) b.quaternion.copy(b.userData.bindQuaternion);
      }
    }

    function sampleChannel(ch, frame) {
      const f0 = Math.floor(frame);
      let f1 = f0 + 1;
      const t = frame - f0;
      if (f1 > ch.last) f1 = ch.first;
      function read(f) {
        if (f < ch.first || f > ch.last) return ch.kind === "q" ? [0,0,0,1] : [0];
        const idx = (f - ch.first) * ch.vlen;
        const out = [];
        for (let i = 0; i < ch.vlen; i++) out.push(ch.data[idx + i] ?? (ch.kind === "q" && i === 3 ? 1 : 0));
        return out;
      }
      const a = read(f0);
      if (!t) return a;
      const b = read(f1);
      if (ch.kind === "q") {
        _tmpQ1.set(a[0], a[1], a[2], a[3]);
        _tmpQ2.set(b[0], b[1], b[2], b[3]);
        _tmpQ1.slerp(_tmpQ2, t);
        return [_tmpQ1.x, _tmpQ1.y, _tmpQ1.z, _tmpQ1.w];
      }
      const o = new Array(ch.vlen);
      for (let i = 0; i < ch.vlen; i++) o[i] = a[i] + (b[i] - a[i]) * t;
      return o;
    }

    function applyClipPose(dtSec) {
      if (!activeClip || !bonesByPivot.size) return;
      const fps = activeClip.frameRate || 30;
      const frameCount = Math.max(1, activeClip.numFrames || 1);
      clipTimeFrames = (clipTimeFrames + fps * dtSec) % frameCount;

      applyBindPose();

      const tByPivot = new Map();
      const qByPivot = new Map();
      for (const ch of activeClip.channels) {
        if (ch.pivot === 0) continue;
        const s = sampleChannel(ch, clipTimeFrames);
        if (ch.kind === "x" || ch.kind === "y" || ch.kind === "z") {
          const t = tByPivot.get(ch.pivot) || [0,0,0];
          if (ch.kind === "x") t[0] = s[0] || 0;
          if (ch.kind === "y") t[1] = s[0] || 0;
          if (ch.kind === "z") t[2] = s[0] || 0;
          tByPivot.set(ch.pivot, t);
        } else if (ch.kind === "q") {
          qByPivot.set(ch.pivot, s);
        }
      }

      const rotFormula = ui.rotFormulaSelect.value;

      // Axis correction setup
      const corrBoneKw = ui.axisCorrBone.value.trim().toLowerCase();
      const corrMode = ui.axisCorrMode.value;
      const corrX = Number(ui.axisCorrX.value) * Math.PI / 180;
      const corrY = Number(ui.axisCorrY.value) * Math.PI / 180;
      const corrZ = Number(ui.axisCorrZ.value) * Math.PI / 180;
      const _corrQ = new THREE.Quaternion().setFromEuler(new THREE.Euler(corrX, corrY, corrZ, 'XYZ'));
      const hasCorrQ = corrBoneKw && (corrX !== 0 || corrY !== 0 || corrZ !== 0);

      for (const [pivot, bone] of bonesByPivot) {
        if (pivot === 0) continue;
        const bp = bone.userData.bindPosition || new THREE.Vector3();
        const bq = bone.userData.bindQuaternion || new THREE.Quaternion();
        const t = tByPivot.get(pivot);
        if (t) {
          // Animation translation is in bone-local (bind-pose) space per W3D source:
          // Transform.Translate(trans) uses pos += currentRot * trans (local space)
          // So we must rotate animTrans by bindQuat before adding to bindPos.
          _tmpV.set(t[0], t[1], t[2]).applyQuaternion(bq);
          bone.position.set(bp.x + _tmpV.x, bp.y + _tmpV.y, bp.z + _tmpV.z);
        } else {
          bone.position.copy(bp);
        }
        const q = qByPivot.get(pivot);
        if (q) {
          _tmpQ1.set(q[0], q[1], q[2], q[3]);
          if (rotFormula === 'B') {
            bone.quaternion.copy(_tmpQ1);
          } else if (rotFormula === 'C') {
            bone.quaternion.copy(_tmpQ1).multiply(bq);
          } else {
            bone.quaternion.copy(bq).multiply(_tmpQ1);
          }
        } else {
          bone.quaternion.copy(bq);
        }
        // Apply axis correction to matching bone
        if (hasCorrQ && bone.name.toLowerCase().includes(corrBoneKw)) {
          if (corrMode === 'pre') {
            bone.quaternion.premultiply(_corrQ);
          } else {
            bone.quaternion.multiply(_corrQ);
          }
        }
      }
    }

    function applyManualBoneOffset() {
      applyBindPose();
      const sel = ui.boneSelect.value;
      if (!sel) return;
      const pivot = Number(sel);
      const bone = bonesByPivot.get(pivot);
      if (!bone) return;
      const bp = bone.userData.bindPosition || new THREE.Vector3();
      const bq = bone.userData.bindQuaternion || new THREE.Quaternion();

      const tx = Number(ui.tx.value), ty = Number(ui.ty.value), tz = Number(ui.tz.value);
      const rx = Number(ui.rx.value) * Math.PI / 180;
      const ry = Number(ui.ry.value) * Math.PI / 180;
      const rz = Number(ui.rz.value) * Math.PI / 180;

      bone.position.set(bp.x + tx, bp.y + ty, bp.z + tz);
      _tmpQ1.setFromEuler(new THREE.Euler(rx, ry, rz, "XYZ"));
      bone.quaternion.copy(bq).multiply(_tmpQ1);
    }

    function resetSkinToBind(mesh) {
      const skin = mesh.userData.cpuSkin;
      if (!skin) return;
      const pos = skin.posAttr;
      const norm = skin.normAttr;
      pos.array.set(skin.bindPositions);
      pos.needsUpdate = true;
      if (norm && skin.bindNormals) {
        norm.array.set(skin.bindNormals);
        norm.needsUpdate = true;
      }
    }

    function applySkinning() {
      const skinMode = ui.skinModeSelect.value;
      for (const mesh of skinnedMeshes) {
        const skin = mesh.userData.cpuSkin;
        if (!skin) continue;
        if (!ui.applySkinChk.checked) {
          resetSkinToBind(mesh);
          continue;
        }

        const meshWorldInv = _tmpM1.copy(mesh.matrixWorld).invert();
        const deformByPivot = [];
        for (const p of skin.usedPivots) {
          const bone = bonesByPivot.get(p);
          const bindInv = skin.bindBoneToMeshInv[p];
          if (!bone) continue;
          _tmpM2.multiplyMatrices(meshWorldInv, bone.matrixWorld);
          if (skinMode === "delta") {
            if (!bindInv) continue;
            _tmpM3.fromArray(bindInv);
            _tmpM2.multiply(_tmpM3);
          }
          deformByPivot[p] = Float32Array.from(_tmpM2.elements);
        }

        const pos = skin.posAttr;
        const norm = skin.normAttr;
        for (let i = 0; i < pos.count; i++) {
          const p = i < skin.links.length ? skin.links[i] : 0;
          const d = deformByPivot[p];
          if (!d) continue;
          _tmpM3.fromArray(d);
          const bi = i * 3;
          _tmpV.set(skin.bindPositions[bi], skin.bindPositions[bi+1], skin.bindPositions[bi+2]).applyMatrix4(_tmpM3);
          pos.setXYZ(i, _tmpV.x, _tmpV.y, _tmpV.z);
          if (norm && skin.bindNormals) {
            _tmpM3n.getNormalMatrix(_tmpM3);
            _tmpN.set(skin.bindNormals[bi], skin.bindNormals[bi+1], skin.bindNormals[bi+2]).applyMatrix3(_tmpM3n).normalize();
            norm.setXYZ(i, _tmpN.x, _tmpN.y, _tmpN.z);
          }
        }
        pos.needsUpdate = true;
        if (norm) norm.needsUpdate = true;
        mesh.geometry.computeBoundingSphere();
      }
    }

    async function refreshClipSelectFromAnimFile() {
      ui.clipSelect.innerHTML = "";
      addSelectOption(ui.clipSelect, "", "(none)");
      activeClip = null;
      clipTimeFrames = 0;

      const animName = ui.animFileSelect.value;
      if (!animName) return;
      const parsed = await parseAndCache(animName);
      if (!parsed || !parsed.animations || !parsed.animations.length) {
        log("Animation file has no animation chunks.");
        return;
      }
      for (const c of parsed.animations) {
        addSelectOption(ui.clipSelect, c.name, `${c.name} (${c.numFrames}f @ ${c.frameRate}fps)`);
      }
      log(`Clips loaded from ${animName}: ${parsed.animations.length}`);
    }

    async function updateActiveClipFromUI() {
      const animName = ui.animFileSelect.value;
      const clipName = ui.clipSelect.value;
      activeClip = null;
      clipTimeFrames = 0;
      if (!animName || !clipName) return;
      const parsed = await parseAndCache(animName);
      if (!parsed) return;
      activeClip = parsed.animations.find(c => c.name === clipName) || null;
      if (activeClip) log(`Active clip: ${clipName}`);
    }

    function frameToFit() {
      const box = new THREE.Box3().setFromObject(worldRoot);
      if (!box.isEmpty()) {
        const size = box.getSize(new THREE.Vector3()).length();
        const center = box.getCenter(new THREE.Vector3());
        controls.target.copy(center);
        camera.position.copy(center).add(new THREE.Vector3(size * 0.5, size * 0.35, size * 0.7));
        camera.near = Math.max(0.1, size / 2000);
        camera.far = Math.max(1000, size * 20);
        camera.updateProjectionMatrix();
      }
    }

    function updateBoneLabels() {
      if (bonesByPivot.size === 0) {
        boneLabelsEl.innerHTML = "";
        ui.cmpResult.textContent = '';
        return;
      }
      if (!ui.showLabelsChk.checked) {
        boneLabelsEl.innerHTML = "";
        // Still run the compare readout even when labels are hidden
        const kwA = ui.cmpBoneA.value.trim().toLowerCase();
        const kwB = ui.cmpBoneB.value.trim().toLowerCase();
        if (kwA || kwB) {
          const _wp = new THREE.Vector3();
          let boneA = null, boneB = null;
          for (const [, b] of bonesByPivot) {
            const nl = b.name.toLowerCase();
            if (kwA && !boneA && nl.includes(kwA)) boneA = b;
            if (kwB && !boneB && nl.includes(kwB)) boneB = b;
          }
          let out = '';
          if (boneA) { _wp.setFromMatrixPosition(boneA.matrixWorld); out += `A "${boneA.name}": (${_wp.x.toFixed(3)},${_wp.y.toFixed(3)},${_wp.z.toFixed(3)})\n`; }
          else if (kwA) { out += `A: no match for "${kwA}"\n`; }
          if (boneB) { _wp.setFromMatrixPosition(boneB.matrixWorld); out += `B "${boneB.name}": (${_wp.x.toFixed(3)},${_wp.y.toFixed(3)},${_wp.z.toFixed(3)})\n`; }
          else if (kwB) { out += `B: no match for "${kwB}"\n`; }
          if (boneA && boneB) {
            const pA = new THREE.Vector3().setFromMatrixPosition(boneA.matrixWorld);
            const pB = new THREE.Vector3().setFromMatrixPosition(boneB.matrixWorld);
            out += `Distance: ${pA.distanceTo(pB).toFixed(4)}`;
          }
          ui.cmpResult.textContent = out;
        } else { ui.cmpResult.textContent = ''; }
        return;
      }
      const host = document.getElementById('canvasHost');
      const W = host.clientWidth, H = host.clientHeight;
      const selectedPivot = ui.boneSelect.value ? Number(ui.boneSelect.value) : -1;
      const kw = ui.highlightInput.value.trim().toLowerCase();
      const kwList = kw ? kw.split(',').map(s => s.trim()).filter(Boolean) : [];

      // Reuse existing label divs if count matches, otherwise rebuild.
      const needed = bonesByPivot.size;
      while (boneLabelsEl.children.length > needed) boneLabelsEl.removeChild(boneLabelsEl.lastChild);
      while (boneLabelsEl.children.length < needed) {
        const d = document.createElement('div');
        d.className = 'bone-label';
        boneLabelsEl.appendChild(d);
      }

      let idx = 0;
      for (const [i, bone] of bonesByPivot) {
        const div = boneLabelsEl.children[idx++];
        _screenPos.setFromMatrixPosition(bone.matrixWorld);
        _screenPos.project(camera);
        const sx = (_screenPos.x * 0.5 + 0.5) * W;
        const sy = (-_screenPos.y * 0.5 + 0.5) * H;
        if (_screenPos.z > 1) { div.style.display = 'none'; continue; }
        div.style.display = '';
        div.style.left = sx + 'px';
        div.style.top  = sy + 'px';
        div.textContent = `${i}:${bone.name}`;
        const nameLow = bone.name.toLowerCase();
        const kwHit = kwList.some(k => nameLow.includes(k));
        div.className = 'bone-label' + (i === selectedPivot || kwHit ? ' highlight' : '');
      }

      // Live compare two bones by partial name match
      const kwA = ui.cmpBoneA.value.trim().toLowerCase();
      const kwB = ui.cmpBoneB.value.trim().toLowerCase();
      if (kwA || kwB) {
        const _wp = new THREE.Vector3();
        let boneA = null, boneB = null;
        for (const [, b] of bonesByPivot) {
          const nl = b.name.toLowerCase();
          if (kwA && !boneA && nl.includes(kwA)) boneA = b;
          if (kwB && !boneB && nl.includes(kwB)) boneB = b;
        }
        let out = '';
        if (boneA) {
          _wp.setFromMatrixPosition(boneA.matrixWorld);
          // Convert from Three.js world to innerGroup-local (W3D model space)
          out += `A "${boneA.name}": pos3js=(${_wp.x.toFixed(3)},${_wp.y.toFixed(3)},${_wp.z.toFixed(3)})\n`;
        } else if (kwA) { out += `A: no match for "${kwA}"\n`; }
        if (boneB) {
          _wp.setFromMatrixPosition(boneB.matrixWorld);
          out += `B "${boneB.name}": pos3js=(${_wp.x.toFixed(3)},${_wp.y.toFixed(3)},${_wp.z.toFixed(3)})\n`;
        } else if (kwB) { out += `B: no match for "${kwB}"\n`; }
        if (boneA && boneB) {
          const pA = new THREE.Vector3().setFromMatrixPosition(boneA.matrixWorld);
          const pB = new THREE.Vector3().setFromMatrixPosition(boneB.matrixWorld);
          const dist = pA.distanceTo(pB);
          out += `Distance A→B: ${dist.toFixed(4)} units`;
        }
        ui.cmpResult.textContent = out;
      } else {
        ui.cmpResult.textContent = '';
      }
    }

    function dumpPivots() {
      if (bonesByPivot.size === 0) { log("No hierarchy loaded."); return; }
      console.group("=== PIVOT DUMP ===");
      const _wpos = new THREE.Vector3();
      for (const [i, bone] of bonesByPivot) {
        const bp = bone.userData.bindPosition;
        const bq = bone.userData.bindQuaternion;
        const parent = bone.parent?.name ?? '(scene)';
        _wpos.setFromMatrixPosition(bone.matrixWorld);
        console.log(
          `[${i}] "${bone.name}"  parent="${parent}"\n` +
          `     bindPos=(${bp?.x.toFixed(4)},${bp?.y.toFixed(4)},${bp?.z.toFixed(4)})\n` +
          `     bindQuat=(x=${bq?.x.toFixed(4)},y=${bq?.y.toFixed(4)},z=${bq?.z.toFixed(4)},w=${bq?.w.toFixed(4)})\n` +
          `     worldPos=(${_wpos.x.toFixed(3)},${_wpos.y.toFixed(3)},${_wpos.z.toFixed(3)})`
        );
      }
      console.groupEnd();
      log("Pivot data dumped to browser console (F12).");
    }

    function logBarrelDirection() {
      if (bonesByPivot.size === 0) { log("No hierarchy loaded."); return; }
      const _m = new THREE.Matrix4();
      const _v = new THREE.Vector3();
      console.group("=== BARREL / BONE-GUN DIRECTION REPORT ===");
      console.log("Rot formula: " + ui.rotFormulaSelect.value);
      for (const [i, bone] of bonesByPivot) {
        const nl = bone.name.toLowerCase();
        if (!nl.includes('gun') && !nl.includes('hand') && !nl.includes('muzzle')) continue;
        _m.extractRotation(bone.matrixWorld);
        _v.set(1, 0, 0).applyMatrix4(_m);
        _v.normalize();
        const wp = new THREE.Vector3().setFromMatrixPosition(bone.matrixWorld);
        const bq = bone.userData.bindQuaternion;
        console.log(
          '[' + i + '] "' + bone.name + '"  parent="' + (bone.parent?.name ?? '?') + '"\n' +
          '  worldPos3js=(' + wp.x.toFixed(3) + ',' + wp.y.toFixed(3) + ',' + wp.z.toFixed(3) + ')\n' +
          '  localX_world=(' + _v.x.toFixed(4) + ',' + _v.y.toFixed(4) + ',' + _v.z.toFixed(4) + ')  <- barrel direction\n' +
          '  bindQuat=(x=' + bq?.x.toFixed(4) + ',y=' + bq?.y.toFixed(4) + ',z=' + bq?.z.toFixed(4) + ',w=' + bq?.w.toFixed(4) + ')\n' +
          '  curQuat=(x=' + bone.quaternion.x.toFixed(4) + ',y=' + bone.quaternion.y.toFixed(4) + ',z=' + bone.quaternion.z.toFixed(4) + ',w=' + bone.quaternion.w.toFixed(4) + ')'
        );
      }
      console.groupEnd();
      log("Barrel direction dumped to console (F12).");
    }

    function animate() {
      requestAnimationFrame(animate);
      const now = performance.now();
      const dt = Math.min((now - lastTime) / 1000, 0.05);
      lastTime = now;

      if (ui.playAnimChk.checked) applyClipPose(dt);
      else applyManualBoneOffset();

      if (modelGroup) modelGroup.updateMatrixWorld(true);
      applySkinning();

      if (skeletonHelper) skeletonHelper.visible = ui.showBonesChk.checked;
      for (const ax of boneAxisHelpers) ax.visible = ui.showAxesChk.checked;
      controls.update();
      renderer.render(scene, camera);
      updateBoneLabels();
    }

    function initThree() {
      const host = document.getElementById("canvasHost");
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.setSize(host.clientWidth, host.clientHeight);
      host.appendChild(renderer.domElement);

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x121212);

      camera = new THREE.PerspectiveCamera(55, host.clientWidth / host.clientHeight, 0.1, 5000);
      camera.position.set(30, 25, 45);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      scene.add(new THREE.GridHelper(120, 24, 0x666666, 0x2a2a2a));
      scene.add(new THREE.AxesHelper(6));
      scene.add(new THREE.AmbientLight(0xffffff, 0.6));
      const dir = new THREE.DirectionalLight(0xffffff, 1.0);
      dir.position.set(20, 35, 15);
      scene.add(dir);

      resetSceneModel();

      window.addEventListener("resize", () => {
        const w = host.clientWidth, h = host.clientHeight;
        renderer.setSize(w, h);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
      });
    }

    // ---------- Events ----------
    ui.fileInput.addEventListener("change", async (e) => {
      for (const f of e.target.files) {
        if (!f.name.toLowerCase().endsWith(".w3d")) continue;
        filesByName.set(f.name.toLowerCase(), f);
      }
      refreshFileSelects();
      log(`Loaded files: ${filesByName.size}`);
    });

    ui.loadModelBtn.addEventListener("click", buildModel);
    ui.refreshClipsBtn.addEventListener("click", refreshClipSelectFromAnimFile);
    ui.dumpPivotsBtn.addEventListener("click", dumpPivots);
    ui.logBarrelBtn.addEventListener("click", logBarrelDirection);

    // Axis correction sliders - live update value labels
    for (const [slider, label] of [[ui.axisCorrX, ui.axisCorrXVal], [ui.axisCorrY, ui.axisCorrYVal], [ui.axisCorrZ, ui.axisCorrZVal]]) {
      slider.addEventListener("input", () => { label.textContent = slider.value + '°'; });
    }
    ui.axisCorrResetBtn.addEventListener("click", () => {
      ui.axisCorrX.value = "0"; ui.axisCorrXVal.textContent = "0°";
      ui.axisCorrY.value = "0"; ui.axisCorrYVal.textContent = "0°";
      ui.axisCorrZ.value = "0"; ui.axisCorrZVal.textContent = "0°";
    });
    ui.axisCorrLogBtn.addEventListener("click", () => {
      const cx = Number(ui.axisCorrX.value) * Math.PI / 180;
      const cy = Number(ui.axisCorrY.value) * Math.PI / 180;
      const cz = Number(ui.axisCorrZ.value) * Math.PI / 180;
      const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(cx, cy, cz, 'XYZ'));
      const msg = 'Bone: "' + ui.axisCorrBone.value + '"  mode=' + ui.axisCorrMode.value + '\n' +
        'Euler: X=' + ui.axisCorrX.value + '° Y=' + ui.axisCorrY.value + '° Z=' + ui.axisCorrZ.value + '°\n' +
        'Quaternion: x=' + q.x.toFixed(6) + ' y=' + q.y.toFixed(6) + ' z=' + q.z.toFixed(6) + ' w=' + q.w.toFixed(6);
      ui.axisCorrResult.textContent = msg;
      console.log('[AXIS CORRECTION]\n' + msg);
    });
    ui.animFileSelect.addEventListener("change", refreshClipSelectFromAnimFile);
    ui.clipSelect.addEventListener("change", updateActiveClipFromUI);

    for (const el of [ui.showMeshChk, ui.showBonesChk, ui.wireChk, ui.showAxesChk]) {
      el.addEventListener("change", updateVisualToggles);
    }

    ui.resetPoseBtn.addEventListener("click", () => {
      ui.rx.value = "0"; ui.ry.value = "0"; ui.rz.value = "0";
      ui.tx.value = "0"; ui.ty.value = "0"; ui.tz.value = "0";
    });

    initThree();
    animate();
    log("W3D Skin Debug Viewer ready.");
  </script>
</body>
</html>
